---

layout: post
title: "RSA"
date: 2025-09-22 13:00:00 +0000
categories: [Cryptography, RSA]
tags: [jekyll, chirpy, static-site, tutorial]
summary: "my ctf writeups."
author: Amine
toc: true
math: true
comments: true
---

## rsa
We’ll use **RSA** to encrypt and decrypt the message `"Securinets{dummy_flag}"`.

### the idea of rsa

RSA is based on **modular arithmetic** and **prime numbers**.
It uses:

* A **public key** → to encrypt
* A **private key** → to decrypt

The math ensures only the private key can decrypt what the public key encrypted.


### steps of rsa

#### step 1: choose two prime numbers

Let’s say:

* ( p = 61 )
* ( q = 53 )

(These are small just for understanding; in real life, primes are **hundreds of digits** long).

#### step 2: compute ( n ) and ( $\varphi(n)$ )

$$ n = p \times q = 61 \times 53 = 3233 $$

$$ \varphi(n) = (p-1)(q-1) = 60 \times 52 = 3120 $$

#### step 3: choose public exponent ( e )

Pick ( e ) such that:

* ( 1 < e < $\varphi(n)$ )
* gcd((e, $\varphi(n)$)) = 1

Choose ( e = 17 ) ✅

#### step 4: Compute private exponent ( d )

Find ( d ) such that:

$$ d \times e \equiv 1    (\text{mod } \varphi(n)) $$

So:

$$ d = 2753 $$

### keys

* **Public key** = (e=17, n=3233)
* **Private key** = (d=2753, n=3233)

### encrypting the message `"Securinets{dummy_flag}"`

RSA works on **numbers**, not letters.
So first, we convert text → ASCII → number.

Example:

* `"S"` = 83
* `"e"` = 101
* `"c"` = 99
  ...

We encrypt each number using:

$$ c = m^e \mod n $$

(where ( m ) is the ASCII value).

Example for `"S"` (83):

$$ c = 83^{17} \mod 3233 = 2081 $$

So `"S"` becomes `2081`.
Do this for every character in `"Securinets{dummy_flag}"`.

### decrypting

To get the message back, use:

$$ m = c^d \mod n $$

Example with ciphertext `2081`:

$$ m = 2081^{2753} \mod 3233 = 83 $$

ASCII `83` = `"S"` ✅

Do this for all numbers, and you recover `"Securinets{dummy_flag}"`.



## key takeaway

* **Encryption:** ( $c = m^e \mod n$ )
* **Decryption:** ( $m = c^d \mod n$ )
* Security comes from the fact that factoring ( n ) into primes is **super hard** if ( n ) is very large.

## math  
### formal definition of modular arithmetic

For integers (a, b, n) (with (n > 0)):

$$ a \equiv b \pmod{n} $$

means that (a) and (b) leave the **same remainder** when divided by (n).
Equivalently:

$$ n | (a-b) \quad \text{(n divides a - b)}. $$


## c program : rsa implementation 

```c
#include <stdio.h>
#include <math.h>
#include <string.h>

// Function to calculate gcd
int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}

// Function to compute (base^exp) % mod
long long mod_exp(long long base, long long exp, long long mod) {
    long long result = 1;
    base = base % mod;
    while (exp > 0) {
        if (exp % 2 == 1)  // if exp is odd
            result = (result * base) % mod;
        exp = exp >> 1;    // divide exp by 2
        base = (base * base) % mod;
    }
    return result;
}

int main() {
    // Step 1: Choose primes (small for demo)
    int p = 61, q = 53;
    int n = p * q;             // modulus
    int phi = (p - 1) * (q - 1);

    // Step 2: Choose public exponent e
    int e = 17;  // commonly used value
    while (gcd(e, phi) != 1) e++;

    // Step 3: Compute private exponent d
    int d = 0;
    for (int k = 1; k < phi; k++) {
        if ((k * e) % phi == 1) {
            d = k;
            break;
        }
    }

    printf("Public key: (e=%d, n=%d)\n", e, n);
    printf("Private key: (d=%d, n=%d)\n\n", d, n);

    // Message to encrypt
    char message[] = "Securinets{dummy_flag}";
    long long encrypted[1024];
    char decrypted[1024];
    int len = strlen(message);

    printf("Original message: %s\n", message);

    // Encrypt each character
    printf("\nEncrypted message (numeric): ");
    for (int i = 0; i < len; i++) {
        encrypted[i] = mod_exp((int)message[i], e, n);
        printf("%lld ", encrypted[i]);
    }
    printf("\n");

    // Decrypt each character
    for (int i = 0; i < len; i++) {
        decrypted[i] = (char)mod_exp(encrypted[i], d, n);
    }
    decrypted[len] = '\0';

    printf("\nDecrypted message: %s\n", decrypted);

    return 0;
}

```



## Wiener's attack